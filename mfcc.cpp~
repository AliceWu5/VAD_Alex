/********************************************************************
*
* Copyright (c) 2017, Vanessa Feng.
*
* Rewrite from Alex-vad-ffnn which is writen by Python, we want to 
* use it to Andrews equipment which writen by Java. Because of better 
* transferring this feature， we need to rewrite it by C or C++.
*
*********************************************************************/
#include "mfcc.h"

MFCCFrontEnd::MFCCFrontEnd(int sample_rate, int frame_size, float preemcoef, int numchans, int num_ceps, int n_frames, bool mel_banks_only){
	
	samplerate = sample_rate;
	framesize = frame_size;
	FFTsize = frame_size;
	filt_size = FFTsize/2+1;
	FiltNum = numchans;
	numceps = num_ceps;
	Hamming = new float[framesize];
	
	//energy = 0.0;
	preemcoef_m = preemcoef;
	mel_only = mel_banks_only;
	n_frames_mf = n_frames;

	data.reserve(framesize);
	mel_energy = new float[FiltNum];
	for(int i=0; i<FiltNum; i++){
		mel_energy[i] = 0.0;
	}

	FiltWeight = new float*[FiltNum];
	for(int i=0; i<FiltNum; i++){
		FiltWeight[i] = new float[filt_size];
		for(int j=0; j<filt_size; j++){
			FiltWeight[i][j] = 0.0;
		}
	}
	w = new float*[FiltNum]; 
	for(int i=0; i<FiltNum; i++){
		w[i] = new float[filt_size];
		for(int j=0; j<filt_size; j++){
			w[i][j] = 0.0;
		}
	}

	mfcc_queue = new float[FiltNum*(1+n_frames)];
	for(int i=0; i<FiltNum*(1+n_frames); i++){
		mfcc_queue[i] = 0.0;
	}
}

MFCCFrontEnd::~MFCCFrontEnd(){
	delete [] Hamming;
	delete [] mel_energy;
	for(int i=0; i<FiltNum; i++){
		delete [] FiltWeight[i];
		delete [] w[i];
	}
	delete [] FiltWeight;
	delete [] w;
}



/********************************** getFMCCs **************************************/
void MFCCFrontEnd::getMFCCs(){
	prior = 0.0;
	HIGH = 3800;
	LOW = 125;
	LOGENERGY = 0;
	if (HIGH>(int) (samplerate/2))    
	   	HIGH=(int) (samplerate/2);
	if (LOW>HIGH)             
	   	LOW=(int)(HIGH/2);
	InitHamming();                    //Create a Hamming window of length framesize
	InitFilt(FiltWeight, FiltNum);    // Initialize filter weights to all zero
	CreateFilt(FiltWeight, FiltNum, samplerate, HIGH, LOW);    	
					  // Compute filter weights:FiltWeight[i][j]
	/*print FiltWeight	
 	for(int i=0;i<FiltNum;i++){
		for(int j=0;j<filt_size;j++){
			cout <<FiltWeight[i][j]<<"\t";
		}
		cout << endl;
	}*/
}
/*xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx*/

float* MFCCFrontEnd::param(vector<float> buffer){		
	out_frame.reserve(framesize);
	
	preemphasis(buffer,out_frame);	
				
        HammingWindow(out_frame,data); 	
	//energy=FrmEnergy(buffer);       //Get frame energy without windowing
	
	computerFFT(data,zero_padded); 	
	mag_square(zero_padded, fft_mag); // This step does magnitude square for the first half of FFT
        Mel_EN(FiltWeight,FiltNum, fft_mag, mel_energy); // This step computes output log energy of each channel
	
	if (mel_only){
		Ceps_melonly(mel_energy,mfcc_queue);
	}
	else{
		Cepstrum(mel_energy,mfcc_queue);
		/**** 再考虑需不需要把添加能量这块去掉 ****/
		//if (LOGENERGY)          // whether to include log energy term or not
		//mfcc_queue.push_back(energy);
	}
	
	data.clear();
	zero_padded.clear();              // clear up fft vector
	fft_mag.clear();                  // clear up fft magnitude 
	//index++;
	return mfcc_queue;
}



/*************************************预处理************************************/
/*预加重：高通滤波器
 *@param vector frame:data of one frame
 *@return vector out_frame.
 */
void MFCCFrontEnd::preemphasis(vector<float> frame, vector<float> &out_frame){
	float sum_frame = 0.0;
	float mean_frame = 0.0;	
	for(int i=0; i<framesize; i++){
		sum_frame += frame[i];
	}	
	mean_frame = sum_frame/framesize;
	for(int i=0; i<framesize; i++){
		frame[i] -= mean_frame;
	}
	out_frame.push_back(frame[0] - preemcoef_m * prior);
	float temp;
	for(int i=1; i<framesize; i++)
	{
		temp = frame[i] - preemcoef_m * frame[i-1];
		out_frame.push_back(temp);
	}
	
	prior = frame[framesize-1];
	//cout << prior << endl;
}

void MFCCFrontEnd::InitHamming(){
	float two_pi=8.0F*atan(1.0F);
	
	float temp;
	for(int i=0; i<framesize; i++)
	{
		Hamming[i] = (float)(0.54-0.46*cos((float) i*two_pi/(float)(framesize-1)));
	}
}

/*加窗：海明窗
 *@param buf data
 */
void MFCCFrontEnd::HammingWindow(vector<float> buf, vector<float> &data){
	for(int i=0; i<framesize; i++)
	{
		data.push_back(buf[i]*Hamming[i]);
	}
}
//回看输入---每帧数据




/********************************** FFT ****************************************/
/*傅立叶变换
 *@param:fftlen=FFTsize--ComputerFFT() operate FFT(FFTsize,vec)
 *可能是引用输出vector，操作FFT为了得到vec
 */
void MFCCFrontEnd::FFT(const unsigned long & fftlen, vector<complex<float> >& vec) 
{ 		 
	unsigned long ulPower = 0;  
	unsigned long fftlen1 = fftlen - 1; 
	while(fftlen1 > 0) 
	{ 
		ulPower++; 
		fftlen1=fftlen1/2; 
	} 

	bitset<sizeof(unsigned long) * 8> bsIndex;
	unsigned long ulIndex; 
	unsigned long ulK; 
	for(unsigned long p = 0; p < fftlen; p++) 
	{ 
		ulIndex = 0; 
		ulK = 1; 
		bsIndex = bitset<sizeof(unsigned long) * 8>(p); 
		for(unsigned long j = 0; j < ulPower; j++) 
		{ 
			ulIndex += bsIndex.test(ulPower - j - 1) ? ulK : 0; 
			ulK *= 2; 
		} 

		if(ulIndex > p) 
		{ 
			complex<float> c = vec[p]; 
			vec[p] = vec[ulIndex]; 
			vec[ulIndex] = c; 
		} 
	} 

	vector<complex<float> > vecW; 
	for(unsigned long i = 0; i < fftlen / 2; i++) 
	{ 
		vecW.push_back(complex<float>(cos(2 * i * PI / fftlen) , -1 * sin(2 * i * PI / fftlen))); 
	} 

	unsigned long ulGroupLength = 1; 
	unsigned long ulHalfLength = 0;  
	unsigned long ulGroupCount = 0;  
	complex<float> cw; 
	complex<float> c1;  
	complex<float> c2;  
	for(unsigned long b = 0; b < ulPower; b++) 
	{ 
	ulHalfLength = ulGroupLength; 
	ulGroupLength *= 2; 
	for(unsigned long j = 0; j < fftlen; j += ulGroupLength) 
	{ 
		for(unsigned long k = 0; k < ulHalfLength; k++) 
		{ 
			cw = vecW[k * fftlen / ulGroupLength] * vec[j + k + ulHalfLength]; 
			c1 = vec[j + k] + cw; 
			c2 = vec[j + k] - cw; 
			vec[j + k] = c1; 
			vec[j + k + ulHalfLength] = c2; 
			} 
		} 
	} 
} 


void MFCCFrontEnd::computerFFT(vector<float> data,vector<complex<float> >& vec) // This function does zero padding and FFT
{	
	for(int i=0;i<FFTsize;i++)     // This step does zero padding
	{
	
	if(i<framesize)
	{	
		complex<float> temp(data[i],0.0);
		vec.push_back(temp);
		
	}
	else
	{
		complex<float> temp(0.0,0.0);
		vec.push_back(temp);
	}
	}
	FFT(FFTsize, vec);    // Compute FFT
}


/********************************* FILTER ***************************************/
/*初始化滤波器，权重为0
 *@param num_filt是语音数据的framesize么
 *
 */
void MFCCFrontEnd::InitFilt(float **w, int num_filt)
{
	int i,j;
	for (i=0;i<num_filt;i++)
		for (j=0;j<filt_size;j++)
			*(*(w+i)+j)=0.0;
}


void MFCCFrontEnd::CreateFilt(float **w, int num_filt, int samplerate, int high, int low)
{
	int df = samplerate/FFTsize;    // FFT interval
	int indexlow=round((float) FFTsize*(float) low/(float) samplerate); // FFT index of low freq limit
	int indexhigh=round((float) FFTsize*(float) high/(float) samplerate); // FFT index of high freq limit
	cout << indexlow <<"\t" << indexhigh<<endl;
	float melmax=2595.0*log10(1.0+(float) high/700.0); // mel high frequency
	float melmin=2595.0*log10(1.0+(float) low/700.0);  // mel low frequency
	float melinc=(melmax-melmin)/(float) (num_filt+1); //mel half bandwidth
	float melcenters[num_filt];        // mel center frequencies
	float fcenters[num_filt];          // Hertz center frequencies
	int indexcenter[num_filt];         // FFT index for Hertz centers
	int indexstart[num_filt];   	   //FFT index for the first sample of each filter
	int indexstop[num_filt];    	   //FFT index for the last sample of each filter
	float increment,decrement; 	   // increment and decrement of the left and right ramp
	float sum=0.0;
	int i,j;
	for (i=1;i<=num_filt;i++)
	{
		melcenters[i-1]=(float) i*melinc+melmin;   // compute mel center frequencies
		fcenters[i-1]=700.0*(pow(10.0,melcenters[i-1]/2595.0)-1.0); // compute Hertz center frequencies
		indexcenter[i-1]=round(fcenters[i-1]/df); // compute fft index for Hertz centers	
		cout << indexcenter[i-1] << endl;	 
   	}
	for (i=1;i<=num_filt-1;i++)  // Compute the start and end FFT index of each channel
	{
		indexstart[i]=indexcenter[i-1];
		indexstop[i-1]=indexcenter[i];		
	}
	indexstart[0]=indexlow;
	indexstop[num_filt-1]=indexhigh;
	for (i=1;i<=num_filt;i++)
	{
	increment=1.0/((float) indexcenter[i-1]-(float) indexstart[i-1]); // left ramp
	for (j=indexstart[i-1];j<=indexcenter[i-1];j++)
		w[i-1][j]=((float)j-(float)indexstart[i-1])*increment;
	  	decrement=1.0/((float) indexstop[i-1]-(float) indexcenter[i-1]);    // right ramp
  	for (j=indexcenter[i-1];j<=indexstop[i-1];j++)
	w[i-1][j]=1.0-((float)j-(float)indexcenter[i-1])*decrement;		 
   	}

   	for (i=1;i<=num_filt;i++)     // Normalize filter weights by sum
   	{
       	for (j=1;j<=filt_size;j++)
	      	sum=sum+w[i-1][j-1];
	for (j=1;j<=filt_size;j++)
	      	w[i-1][j-1]=w[i-1][j-1]/sum;
	sum=0.0;
	}
}


/********************************** Cepstrum ************************************/

void MFCCFrontEnd::mag_square(vector<complex<float> > &vec, vector<float> &vec_mag) // This function computes magnitude squared FFT
{
	int i;
	float temp;
	for (i=1;i<=filt_size;i++)
	{
		temp = vec[i-1].real()*vec[i-1].real()+vec[i-1].imag()*vec[i-1].imag();
		vec_mag.push_back(temp);
	}	   	   
}

void MFCCFrontEnd::Mel_EN(float **w,int num_filt, vector<float>& vec_mag, float * M_energy) // computes log energy of each channel
{
	int i,j;
	for (i=1;i<=num_filt;i++)    // set initial energy value to 0
		M_energy[i-1]=0.0F;
   
   	for (i=1;i<=num_filt;i++)
   	{
     		for (j=1;j<=filt_size;j++){
       		  	M_energy[i-1]=M_energy[i-1]+w[i-1][j-1]*vec_mag[j-1];
			cout << w[i-1][j-1] << "\t";
		}	
     		M_energy[i-1]=(float)(log(M_energy[i-1]));	
		//cout << M_energy[i-1] << "\t";	 
   	}
	cout << endl;
	cout << endl;
}


void MFCCFrontEnd::Cepstrum(float *M_energy,float *mfcc_queue)
{
	int i,j;
	float Cep[numceps];
    	for (i=1;i<=numceps;i++)
	{ 
		Cep[i-1]=0.0F;    // initialize to 0
	  	for (j=1;j<=FiltNum;j++)
          		Cep[i-1]=Cep[i-1]+M_energy[j-1]*cos(PI*((float) i)/((float) FiltNum)*((float) j-0.5F)); // DCT transform
      		Cep[i-1]=sqrt(2.0/float (FiltNum))*Cep[i-1];
		mfcc_queue[i-1] = Cep[i-1];   // store cepstrum in this vector
    	}	
	  
}

void MFCCFrontEnd::Ceps_melonly(float *M_energy, float *mfcc_queue)
{	
	
	int t = FiltNum*(1+n_frames_mf);
	
	for (int i=t;i>=FiltNum+1;i--){
		mfcc_queue[i-1] = mfcc_queue[i-1-FiltNum];
	}
	for (int i=1; i<=FiltNum; i++){
		mfcc_queue[i-1] = M_energy[i-1];
	}
	/*
	for(int i=0; i<t; i++){
		cout << mfcc_queue[i] <<"\t";
	}
	cout << endl;
	cout << endl;
	*/
}
		

















